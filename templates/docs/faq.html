{% extends 'docs/base_docs.html' %}

{% block title %}FAQ | Dqlite{% endblock %}

{% block meta_description %}Frequently asked questions about dqlite{% endblock %}

{% block docs_content %}
<h1>FAQ</h1>
<p><strong>Table of contents</strong></p>
<ol>
  <li>
    <a href="#what-are-the-use-cases">What are the use cases?</a>
  </li>
  <li>
    <a href="#whos-using-dqlite">Who's using dqlite?</a>
  </li>
  <li>
    <a href="#is-there-247-support-available">Is there 24/7 support available?</a>
  </li>
  <li>
    <a href="#is-there-a-commitment-to-long-term-releases">Is there a commitment to long term releases?</a>
  </li>
  <li>
    <a href="#how-does-dqlite-behave-during-conflict-situations">How does dqlite behave during conflict situations?</a>
  </li>
  <li>
    <a href="#when-not-enough-nodes-are-available">When not enough nodes are available, are writes hung until consensus?</a>
  </li>
  <li>
    <a href="#how-does-dqlite-compare-to-rqlite">How does dqlite compare to rqlite?</a>
  </li>
  <li>
    <a href="#why-c">Why C?</a>
  </li>
</ol>

<h2 id="what-are-the-use-cases">What are the use cases?</h2>
<p>
  If don&rsquo;t want to depend on an external database (e.g. you&rsquo;d like to use SQLite) but yet you want your application to be highly-available (e.g you have 3 nodes, and you want your data and service uptime to survive in case a node is lost), then dqlite is for you.
</p>
<p>
  We think this choice is particularly appropriate for IoT and Edge devices, but also for agents and backend cloud services that wish to simplify their operation.
</p>

<h2 id="whos-using-dqlite">Who's using dqlite?</h2>
<p>
  At the moment the biggest user of dqlite is the <a href="https://linuxcontainers.org/lxd/introduction/">LXD</a> system containers manager, which uses dqlite to implement high-availability when run in cluster mode. See the relevant <a href="https://github.com/lxc/lxd/blob/master/doc/clustering.md">documentation</a>.
</p>

<h2 id="are-windows-and-macos-supported">Are Windows and macOS supported?</h2>
<p>
  Not at the moment, because under the hood dqlite uses the Linux-specific <code>io_submit</code> asynchronous file system write API. That code leaves behind an interface that could be adapted to OSX and Windows though. See also this <a href="https://github.com/canonical/go-dqlite/issues/21">issue</a>.
</p>

<h2 id="is-there-247-support-available">Is there 24/7 support available?</h2>
<p>
  Not at the moment. But <a href="https://www.canonical.com">Canonical</a>, the company who&rsquo;s funding dqlite, can arrange a support contract if desired.
</p>

<h2 id="is-there-a-commitment-to-long-term-releasee">
  Is there a commitment to long term releases?
</h2>
<p>
  The v1 series will be maintained, improved and bug-fixed for the foreseeable future and backward compatibility is guaranteed.
</p>

<h2 id="how-does-dqlite-behave-during-conflict-situations">
  How does dqlite behave during conflict situations?
</h2>
<p>
  Does Raft select a winning WAL write and any others in flight writes are aborted?
</p>
<p>
  There can&rsquo;t be a conflict situation. Raft&rsquo;s model is that only the leader can append new log entries, which translated to dqlite means that only the leader can write new WAL frames. So this means that any attempt to perform a write transaction on a non-leader node will fail with a ErrNotLeader error (and in this case clients are supposed to retry against whoever is the new leader).
</p>

<h2 id="when-not-enough-nodes-are-available">
  When not enough nodes are available, are writes hung until consensus?
</h2>
<p>
  Yes, however there&rsquo;s a (configurable) timeout. This is a consequence of Raft sitting in the CP spectrum of the CAP theorem: in case of a network partition it chooses consistency and sacrifices availability.
</p>

<h2 id="how-does-dqlite-compare-to-rqlite">
  How does dqlite compare to rqlite?
</h2>
<p>
  The main differences from <a href="https://github.com/rqlite/rqlite">rqlite</a> are:
</p>
<ul>
  <li>Embeddable in any language that can interoperate with C</li>
  <li>Full support for transactions</li>
  <li>No need for statements to be deterministic (e.g. you can use <code>time()</code>)</li>
  <li>Frame-based replication instead of statement-based replication</li>
</ul>

<h2 id="why-c">Why C?</h2>
<p>
  The first prototype implementation of dqlite was in Go, leveraging the <a href="https://github.com/hashicorp/raft/">hashicorp/raft</a> implementation of the Raft algorithm. The project was later rewritten entirely in C because of performance problems due to the way Go interoperates with C: Go considers a function call into C that lasts more than &#126;20 microseconds as a blocking system call, in that case it will put the goroutine running that C call in waiting queue and resuming it will effectively cause a context switch, degrading performance (since there were a lot of them happening). See also <a href="https://github.com/golang/go/issues/19574">this issue</a> in the Go bug tracker.
</p>
<p>
  The added benefit of the rewrite in C is that it&rsquo;s now easy to embed dqlite into project written in effectively any language, since all major languages have provisions to create C bindings.
</p>
{% endblock docs_content %}
